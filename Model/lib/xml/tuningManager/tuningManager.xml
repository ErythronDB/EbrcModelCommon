<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <tuningTable name="SampleId" prefixEnabled="false">
    <comment>Which protocol app nodes for sample record                                                                                                    
    </comment>
    <externalDependency name="study.ProtocolAppNode"/>
    <sql>
      <![CDATA[
create table SampleId&1 as 
select protocol_app_node_id, name from study.protocolappnode where isa_type = 'Sample'
union
select pan.protocol_app_node_id, pan.name
from study.study s
   , sres.externaldatabase d
   , sres.externaldatabaserelease r
   , study.protocolappnode pan
   , study.studylink sl
where s.external_database_release_id = r.external_database_release_id
and r.external_database_id = d.external_database_id
and s.study_id = sl.study_id
and sl.protocol_app_node_id = pan.protocol_app_node_id
and d.name like '%isolates_genbank_RSRC'
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ExternalSequenceTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for 16S reference organisms                                                                                                     
    </comment>
    <externalDependency name="dots.ExternalNASequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table ExternalSequenceTaxonRank&1 nologging as
with organism_rank as (
select tn1.taxon_id as organism, tn2.name as parent_organism, 
           tn2.taxon_id as parent_organism_id, r.rank
from (
select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
from sres.taxon
start with taxon_id in (  select taxon_id from DOTS.EXTERNALNASEQUENCE
                        union
                          select taxon_id from apidb.SequenceTaxon)
connect by prior parent_id = taxon_id) r
, sres.taxonname tn1
, sres.taxonname tn2
where r.input = tn1.taxon_id
and r.taxon_id = tn2.taxon_id
and tn1.name_class = 'scientific name'
and tn2.name_class = 'scientific name'
and r.rank in ('phylum', 'family','genus', 'species', 'superkingdom','kingdom', 'class', 'order')
)

select organisms.organism, 
        nvl(superkingdom.parent_organism, 'N/A') as superkingdom,
        superkingdom.parent_organism_id as superkingdom_id,
        nvl(kingdom.parent_organism, 'N/A') as kingdom,
        kingdom.parent_organism_id as kingdom_id,
        nvl (phylum.parent_organism, 'N/A') as phylum,
        phylum.parent_organism_id as phylum_id,
        nvl (class.parent_organism, 'N/A') as class,
        class.parent_organism_id as class_id,
        nvl (family.parent_organism, 'N/A') as family,
        family.parent_organism_id as family_id,
        nvl (rank_order.parent_organism, 'N/A') as rank_order,
        rank_order.parent_organism_id as rank_order_id,
        nvl ( genus.parent_organism, 'N/A') as genus,
        genus.parent_organism_id as genus_id,
        nvl(species.parent_organism, 'N/A') as species,
        species.parent_organism_id as species_id
from 
(select distinct organism from organism_rank) organisms,
(select * from organism_rank where rank= 'phylum') phylum,
(select * from organism_rank where rank= 'genus') genus,
(select * from organism_rank where rank= 'species') species,
(select * from organism_rank where rank= 'kingdom') kingdom,
(select * from organism_rank where rank= 'superkingdom') superkingdom,
(select * from organism_rank where rank= 'class') class,
(select * from organism_rank where rank= 'family') family,
(select * from organism_rank where rank= 'order') rank_order
where organisms.organism = phylum.organism (+)
and organisms.organism = genus.organism (+)
and organisms.organism = species.organism (+)
and organisms.organism = kingdom.organism (+)
and organisms.organism = class.organism (+)
and organisms.organism = rank_order.organism (+)
and organisms.organism = family.organism (+)
and organisms.organism = superkingdom.organism (+)
 ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonAbundance" prefixEnabled="false">
    <comment>otu relative abundance values, aggegated at various taxonomic levels
    </comment>
    <externalDependency name="results.OtuAbundance"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        CREATE TABLE TaxonAbundance&1 NOLOGGING AS
        WITH leaf_abundance
        AS (SELECT oa.protocol_app_node_id, oa.raw_count AS raw_count,
                   oa.relative_abundance AS relative_abundance,
                   CASE
                     WHEN st.taxon_id IS NOT NULL
                       THEN st.taxon_id
                     ELSE ens.taxon_id
                   END AS taxon_id
            FROM results.OtuAbundance oa, dots.ExternalNaSequence ens, apidb.SequenceTaxon st
            WHERE oa.na_sequence_id = ens.na_sequence_id
              AND ens.na_sequence_id = st.na_sequence_id(+)
           ),
        taxa_string_map
        AS (  SELECT DECODE(REPLACE(estr.kingdom, 'N/A', 'unknown'), 'unknown',
                            REPLACE(estr.superkingdom, 'N/A', 'unknown'), estr.kingdom) AS taxon_string
                     , 'kingdom' AS taxon_node
                     , nvl(kingdom_id, superkingdom_id) AS taxon_id
                     , 1 AS taxon_level
                     , la.protocol_app_node_id
                     , la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.phylum, 'N/A', 'unknown') AS taxon_string
                     , 'phylum' AS taxon_node
                     , phylum_id AS taxon_id
                     , 2 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.class, 'N/A', 'unknown') AS taxon_string
                     , 'class' AS taxon_node
                     , class_id AS taxon_id
                     , 3 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.rank_order, 'N/A', 'unknown')as taxon_string
                     , 'order' AS taxon_node
                     , rank_order_id AS taxon_id
                     , 4 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.family, 'N/A', 'unknown') AS taxon_string
                     , 'family' AS taxon_node
                     , family_id AS taxon_id
                     , 5 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.genus, 'N/A', 'unknown') AS taxon_string
                     , 'genus' AS taxon_node
                     , genus_id AS taxon_id
                     , 6 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.species, 'N/A', 'unknown') AS taxon_string
                     , 'species' AS taxon_node
                     , species_id AS taxon_id
                     , 7 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
           ),
        agg_taxon_string_map
        AS (SELECT taxon_string AS taxon_name, taxon_node,
                   taxon_node || '|' || taxon_id AS taxon_id, taxon_level,
                   protocol_app_node_id, SUM(relative_abundance) AS relative_abundance,
                   SUM(raw_count) AS raw_count
            FROM taxa_string_map
            GROUP BY taxon_string, taxon_node, taxon_node || '|' || taxon_id,
                     taxon_level, protocol_app_node_id
           )
        SELECT tsm.protocol_app_node_id, pan.name AS pan_name,
               initcap(tsm.taxon_node) AS category, CAST(tsm.taxon_name AS VARCHAR2(200)) AS term,
               tsm.taxon_id AS term_id, ds.name AS dataset_name, ds.type, ds.subtype,
               study_release.study_name, study_release.investigation_name,
               tsm.taxon_level, tsm.raw_count AS agg_count, tsm.relative_abundance AS value
        FROM agg_taxon_string_map tsm,
             study.ProtocolAppNode pan,
             study.StudyLink sl,
             sres.ExternalDatabaseRelease edr,
             sres.ExternalDatabase ed,
             apidb.Datasource ds,
             (SELECT s.study_id, i.external_database_release_id,
                     s.name AS study_name, i.name AS investigation_name
              FROM study.Study s, study.Study i
              WHERE s.investigation_id = i.study_id
                AND s.name not like '%[%]%'
                AND i.name like 'OTU Profile%'
              ) study_release
        WHERE tsm.protocol_app_node_id = pan.protocol_app_node_id
          AND tsm.protocol_app_node_id = sl.protocol_app_node_id
          AND sl.study_id = study_release.study_id
          AND study_release.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name = ds.name
 ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TaxAbund_panId_Term&1
          ON TaxonAbundance&1 (protocol_app_node_id, term_id,  category, term)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProtocolAppNodeRecord" prefixEnabled="false">
   <comment>Input to pan meta data tables</comment>
    <externalDependency name="study.protocolappnode"/>
    <externalDependency name="sres.ontologyterm"/>
    <externalDependency name="study.studylink"/>
    <externalDependency name="study.study"/>
    <externalDependency name="sres.externaldatabase"/>
    <externalDependency name="sres.externaldatabaserelease"/>
    <sql>
      <![CDATA[
create table ProtocolAppNodeRecord&1 as
select distinct pan.PROTOCOL_APP_NODE_ID, pan.name as pan_name, ot.name as type
from study.protocolappnode pan
   , sres.ontologyterm ot
   , study.studylink sl
   , study.study s
   , sres.externaldatabase d
   , SRES.EXTERNALDATABASERELEASE r
where ot.ONTOLOGY_TERM_ID = pan.type_id
and pan.PROTOCOL_APP_NODE_ID = sl.PROTOCOL_APP_NODE_ID
and sl.study_id = s.study_id
and s.EXTERNAL_DATABASE_RELEASE_ID = r.EXTERNAL_DATABASE_RELEASE_ID
and r.EXTERNAL_DATABASE_ID = d.external_database_id
and d.name = 'JB_PRISM_META_DATA'
and ot.name in ('study participant information',
                'clinical visit information',
                'specimen',
                'dwelling',
                'CDC light trap assay')
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProtocolAppNodeResults" prefixEnabled="false">
    <comment>Table of protocol app node ids and the name of the result table where they are referenced
    </comment>
    <externalDependency name="results.NaFeatureDiffResult"/>
    <externalDependency name="results.ReporterIntensity"/>
    <externalDependency name="results.SegmentResult"/>
    <externalDependency name="results.CompoundMassSpec"/>
    <externalDependency name="results.NaFeatureHostResponse"/>
    <externalDependency name="results.NaFeatureExpression"/>
    <externalDependency name="results.EditingEvent"/>
    <externalDependency name="results.FamilyDiffResult"/>
    <externalDependency name="results.FamilyExpression"/>
    <externalDependency name="results.GeneDiffResult"/>
    <externalDependency name="results.GeneExpression"/>
    <externalDependency name="results.GeneSimilarity"/>
    <externalDependency name="results.ReporterDiffResult"/>
    <externalDependency name="results.ReporterExpression"/>
    <externalDependency name="results.RnaDiffResult"/>
    <externalDependency name="results.RnaExpression"/>
    <externalDependency name="results.SegmentDiffResult"/>
    <externalDependency name="results.SeqVariation"/>
    <externalDependency name="results.OtuAbundance"/>
    <externalDependency name="results.AlphaDiversity"/>    
    <externalDependency name="apidb.SequenceVariation"/>
    <externalDependency name="apidb.MassSpecSummary"/>
    <externalDependency name="apidb.ChrCopyNumber"/>
    <externalDependency name="apidb.GeneCopyNumber"/>
    <externalDependency name="apidb.IntronJunction"/>
    <externalDependency name="apidb.RflpGenotype"/>
    <externalDependency name="apidb.RflpGenotypeNumber"/>
    <externalDependency name="apidb.crisprphenotype"/>
    <sql>
      <![CDATA[
    create table ProtocolAppNodeResults&1 as
      select protocol_app_node_id, 'Results::NAFeatureDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterIntensity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterIntensity)
    union
      select protocol_app_node_id, 'Results::SegmentResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentResult)
    union
      select protocol_app_node_id, 'Results::CompoundMassSpec' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.CompoundMassSpec)
    union
      select protocol_app_node_id, 'Results::NaFeatureHostResponse' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NaFeatureHostResponse)
    union
      select protocol_app_node_id, 'ApiDB::ChrCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.ChrCopyNumber)
    union
      select protocol_app_node_id, 'ApiDB::GeneCopyNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from ApiDB.GeneCopyNumber)
    union
      select protocol_app_node_id, 'Results::NAFeatureExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.NAFeatureExpression)
    union
      select protocol_app_node_id, 'Results::EditingEvent' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.EditingEvent)
    union
      select protocol_app_node_id, 'Results::FamilyDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyDiffResult)
    union
      select protocol_app_node_id, 'Results::FamilyExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.FamilyExpression)
    union
      select protocol_app_node_id, 'Results::GeneDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneDiffResult)
    union
      select protocol_app_node_id, 'Results::GeneExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneExpression)
    union
      select protocol_app_node_id, 'Results::GeneSimilarity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.GeneSimilarity)
    union
      select protocol_app_node_id, 'Results::ReporterDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterDiffResult)
    union
      select protocol_app_node_id, 'Results::ReporterExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.ReporterExpression)
      union
    select protocol_app_node_id, 'Results::RnaDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaDiffResult)
      union
    select protocol_app_node_id, 'Results::RnaExpression' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.RnaExpression)
      union
    select protocol_app_node_id, 'Results::OtuAbundance' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.OtuAbundance)
    union
    select protocol_app_node_id, 'Results::AlphaDiversity' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.AlphaDiversity)
    union
    select protocol_app_node_id, 'Results::SegmentDiffResult' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SegmentDiffResult)
    union
      select protocol_app_node_id, 'Results::SeqVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from Results.SeqVariation)
    union
      select protocol_app_node_id, 'ApiDB::SequenceVariation' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.sequencevariation)
    union
      select protocol_app_node_id, 'ApiDB::MassSpecSummary' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.MASSSPECSUMMARY)
    union
      select protocol_app_node_id, 'ApiDB::IntronJunction' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.IntronJunction)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotype)
    union
      select protocol_app_node_id, 'ApiDB::RflpGenotypeNumber' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.RflpGenotypeNumber)
    union
      select protocol_app_node_id, 'ApiDB::CrisprPhenotype' as result_table from study.ProtocolAppNode
      where protocol_app_node_id in (select protocol_app_node_id from apidb.crisprphenotype)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="PANProtocolMetadata" prefixEnabled="false">
    <comment>
    </comment>
    <internalDependency name="ProtocolAppNodeResults"/>
    <internalDependency name="ProtocolAppNodeRecord"/>
    <internalDependency name="SampleId"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <externalDependency name="study.ProtocolApp"/>
    <externalDependency name="study.Input"/>
    <externalDependency name="study.Output"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Characteristic"/>
    <externalDependency name="study.Protocol"/>
    <externalDependency name="study.ProtocolParam"/>
    <externalDependency name="study.ProtocolAppParam"/>
    <ancillaryTable name="ProtocolAppNodeIO"/>
    <ancillaryTable name="PANCharacteristicMetadata"/>
    <ancillaryTable name="SampleCharMetadata"/>
    <ancillaryTable name="SampleProtocolMetadata"/>
    <ancillaryTable name="SampleDownstream"/>
    <ancillaryTable name="PANExternalDatabaseRelease"/>
    <ancillaryTable name="PANParameterValues"/>
    <sql>
      <![CDATA[
        create table ProtocolAppNodeIO&1 nologging as
        select i.protocol_app_node_ID input_node_id, pa.protocol_app_id, o.protocol_app_node_id output_node_id
        from study.ProtocolApp pa, study.Input i, study.Output o
        where i.protocol_app_id = pa.protocol_app_id
          and o.protocol_app_id = pa.protocol_app_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANProtocolMetadata&1 nologging as
   with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO&1
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodeResults)
            connect by prior input_node_id = output_node_id
            )
         ,param_term_id
         as ( select pp.protocol_param_id, min(ot.ontology_term_id) as ontology_term_id  
              from STUDY.PROTOCOLPARAM pp, SRES.ONTOLOGYTERM ot
              where ot.name = pp.name
              group by pp.protocol_param_id
              )
        select node_inputs.protocol_app_node_id, ds.name as dataset_name,
               case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               p.name as category, pan.name as pan_name, pp.name as term, param_term_id.ontology_term_id as term_id,
               pap.value, pap.protocol_app_param_id, ds.type, ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, param_term_id, study.ProtocolAppParam pap, 
             study.ProtocolParam pp, study.Protocol p, study.StudyLink sl, 
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             apidb.Datasource ds, study.ProtocolAppNode pan, sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation' -- avoid data transformation protocol parameters
          and pp.PROTOCOL_PARAM_ID = param_term_id.protocol_param_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANCharacteristicMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from ProtocolAppNodeIO&1
            start with output_node_id in (select protocol_app_node_id from ProtocolAppNodeResults)
            connect by prior input_node_id = output_node_id
           )
select sample_pan.protocol_app_node_id, nvl(mt.name, 'assay') as category, attribute_term.name as term, -- if not a material type it has to be an assay
               attribute_term.ontology_term_id as term_id, 
               case when apidb.is_number(c.value) = 1
                    then to_char(nvl(round(c.value, 2), 0))
                    else nvl(c.value, value_term.name)
               end as value,
               c.characteristic_id,
               ds.name as dataset_name, sample_pan.name as pan_name, ds.type,
               case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               ds.subtype, tn.name as organism,
               study_release.study_name, study_release.investigation_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyTerm mt, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed, sres.OntologyTerm attribute_term,
             apidb.Datasource ds, sres.TaxonName tn, study.ProtocolAppNode sample_pan,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id (+)
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
          and ds.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
 and (mt.name is not null or attribute_term.name = 'average mapping coverage' or attribute_term.name ='proportion mapped reads') --temporary may need adjusting for RNASeq      
 UNION
select pan.protocol_app_node_id, mt.name as category, attribute_term.name as term,
               attribute_term.ontology_term_id as term_id, 
               case when apidb.is_number(c.value) = 1
                    then to_char(nvl(round(c.value, 2), 0))
                    else nvl(c.value, value_term.name)
               end as value,
               c.characteristic_id,
               'TODO' as dataset_name, pan.name as pan_name, 'TODO' as type,
'JB_PRISM_ONTOLOGY' as hierarchy_dataset_name, -- TODO... fix when reload
               'TODO' as subtype, null as organism,
               study_release.study_name, study_release.investigation_name
        from ProtocolAppNodeRecord panrec, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyTerm mt, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed, sres.OntologyTerm attribute_term,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
             ) study_release
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id (+)
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and panrec.protocol_app_node_id = pan.protocol_app_node_id
          and panrec.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
 ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleCharMetadata&1 nologging as
     with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select sample_pan.protocol_app_node_id, mt.name as category, attribute_term.name as term,
               attribute_term.ontology_term_id as term_id, nvl(c.value, value_term.name) as value, c.characteristic_id,
                sample_pan.name as pan_name
        from node_inputs, study.ProtocolAppNode pan, study.Characteristic c, sres.OntologyTerm value_term,
             sres.ontologyterm mt, 
             sres.ontologyterm attribute_term,
             study.ProtocolAppNode sample_pan
        where pan.protocol_app_node_id = c.protocol_app_node_id
          and pan.type_id = mt.ontology_term_id
          and c.ontology_term_id = value_term.ontology_term_id(+)
          and c.qualifier_id = attribute_term.ontology_term_id(+)
          and node_inputs.input_node_id = pan.protocol_app_node_id
          and node_inputs.protocol_app_node_id = sample_pan.protocol_app_node_id
        union
       select pan.protocol_app_node_id, mt.name, ot.name, ot.ontology_term_id, nvl(c.value, vot.name) as value, c.characteristic_id, pan.name
        from study.protocolappnode pan
           , sres.ontologyterm mt
           , study.characteristic c
           , sres.ontologyterm ot
           , sres.ontologyterm vot
        where pan.protocol_app_node_id in  (select protocol_app_node_id from sampleid)
         and pan.protocol_app_node_id = c.protocol_app_node_id
         and c.qualifier_id = ot.ontology_term_id
         and c.ontology_term_id = vot.ontology_term_id (+)
         and pan.type_id = mt.ontology_term_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
      create table SampleProtocolMetadata&1 nologging as
        with node_inputs
        as (select connect_by_root output_node_id as protocol_app_node_id, input_node_id, protocol_app_id
            from protocolappnodeio&1
            start with output_node_id in (select protocol_app_node_id from sampleid)
            connect by prior input_node_id = output_node_id
           )
        select node_inputs.protocol_app_node_id, 
               p.name as category, 
               pan.name as pan_name, 
               pp.name as term,
               pap.value, 
               pap.protocol_app_param_id
        from node_inputs
           , study.protocolappparam pap
           , study.protocolparam pp
           , study.protocol p
           , study.ProtocolAppNode pan
        where node_inputs.protocol_app_id = pap.protocol_app_id
          and pap.protocol_param_id = pp.protocol_param_id
          and pp.protocol_id = p.protocol_id
          and node_inputs.protocol_app_node_id = pan.protocol_app_node_id
          and p.name not like '%::%' -- avoid Perl class names
          and p.name not like '%data transformation'
      ]]>
    </sql>

    <sql>
      <![CDATA[
create table SampleDownstream&1 nologging as
SELECT
  p1.name
, p1.protocol_app_node_id
, p3.name as input
, p3.protocol_app_node_id as input_protocol_app_node_id
, case
    WHEN ot3.name LIKE 'data%'
    THEN 'Data'
    else p3.isa_type
  end as input_isa_type
, ot3.name as input_material_type
, p.name AS protocol
, p2.name AS output
, p2.protocol_app_node_id AS output_protocol_app_node_id
, case
    WHEN ot2.name LIKE 'data%'
    THEN 'Data'
    else p2.isa_type
  end as output_isa_type
, ot2.name AS output_material_type
FROM
  (SELECT
    connect_by_root input_node_id AS protocol_app_node_id
  , input_node_id
  , output_node_id
  , protocol_app_id
  from
    protocolappnodeio&1
    start with input_node_id in (SELECT protocol_app_node_id FROM sampleid)
    CONNECT BY prior output_node_id = input_node_id
  ) io
, study.protocolappnode p1
, study.protocolappnode p2
, study.protocolappnode p3
, sres.ontologyterm ot2
, sres.ontologyterm ot3
, study.protocol p
, study.protocolapp pa
WHERE
  io.protocol_app_node_id = p1.protocol_app_node_id
  and io.output_node_id = p2.protocol_app_node_id
  and io.input_node_id = p3.protocol_app_node_id
  and p2.type_id = ot2.ontology_term_id (+)
  and p3.type_id = ot3.ontology_term_id (+)
  and io.protocol_app_id = pa.protocol_app_id
  and pa.protocol_id = p.protocol_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
 create table PANExternalDatabaseRelease&1 nologging as
SELECT DISTINCT
  sl.protocol_app_node_id
, s.external_database_release_id
FROM
  study.study s
, study.studylink sl
WHERE
  s.study_id = sl.study_id
  and s.external_database_release_id is not null
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create table PANParameterValues&1 nologging as
select
  p.name as protocol
, pp.name as protocol_param
, pap.value as protocol_param_value
, pan.name as protocol_app_node_name
, pan.protocol_app_node_id
FROM
  study.protocolappparam pap
, study.protocolparam pp
, study.protocol p
, protocolappnodeio&1 io
, study.protocolappnode pan
WHERE
  pp.protocol_param_id = pap.protocol_param_id
  AND p.protocol_id = pp.protocol_id
  AND io.protocol_app_id = pap.protocol_app_id
  AND io.output_node_id = pan.protocol_app_node_id
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="FallbackMetadata">
    <comment>
      For datasets that have results but no metadata, a fallback set of metadata comprising the name of each ProtocolAppNode
    </comment>
    <internalDependency name="ProtocolAppNodeResults"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <sql>
      <![CDATA[
        create table FallbackMetadata&1 nologging as
        -- regular query for most datasets
        select ds.name as dataset_name, ds.type, ds.subtype, tn.name as organism,
              case
                       when lower(ds.name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(ds.name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name,
               pan.name as pan_name, pan.protocol_app_node_id, 'dataset' as term_name,
               study_release.study_name, study_release.investigation_name, dsp.display_name as value
        from study.ProtocolAppNode pan, apidb.Datasource ds, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release, 
             DatasetPresenter dsp
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodeResults)
--        and ds.name not in (select dataset_name from PANProtocolMetadata)
--        and ds.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name = ds.name
          and ds.taxon_id = tn.taxon_id(+)
          and ds.name = dsp.name (+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
UNION
        -- special query for reference strain
        select ed.name as dataset_name, 'SNP' as type, 'HTS_SNP' as subtype, tn.name as organism,
               null as hierarchy_dataset_name,
               o.strain_abbrev as pan_name, pan.protocol_app_node_id, 'dataset' as term_name,
               study_release.study_name, study_release.investigation_name, 'Reference Genome'
        from study.ProtocolAppNode pan, study.StudyLink sl,
             sres.ExternalDatabaseRelease edr, sres.ExternalDatabase ed,
             sres.TaxonName tn, apidb.Organism o,
             (  select s.study_id, i.external_database_release_id,
                       s.name as study_name, i.name as investigation_name
                from study.Study s, study.Study i
                where s.investigation_id = i.study_id
              union
                select s.study_id, s.external_database_release_id,
                       s.name as study_name, null as investigation_name
                from study.Study s) study_release
        where pan.protocol_app_node_id in (select protocol_app_node_id
                                           from ProtocolAppNodeResults)
--        and ed.name not in (select dataset_name from PANProtocolMetadata)
--        and ed.name not in (select dataset_name from PANCharacteristicMetadata)
          and pan.protocol_app_node_id = sl.protocol_app_node_id
          and sl.study_id = study_release.study_id
          and study_release.external_database_release_id = edr.external_database_release_id
          and edr.external_database_id = ed.external_database_id
          and ed.name like '%_NGS_SNPsAndVariations'
          and o.abbrev = replace(ed.name, '_NGS_SNPsAndVariations', '')
          and o.taxon_id = tn.taxon_id(+)
          and (tn.name_class = 'scientific name' or tn.name_class is null)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MetadataSpec">
    <comment>
    </comment>
    <internalDependency name="FallbackMetadata"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="MetadataType"/>
    <sql>
      <![CDATA[
        create table MetadataSpec&1 nologging as
        select * from (
        with hierarchy_mapping
        as (select dataset_name,
                   case
                       when lower(dataset_name) like '%microarrayantibody%'
                            then 'Ontology_icemr_RSRC'
                       when lower(dataset_name) like 'otu%'
                            then 'Ontology_microbiomeHierarchy_RSRC'
                       else null
                       end as hierarchy_dataset_name
            from (  select dataset_name
                    from FallbackMetadata
                  union
                    select dataset_name
                    from panCharacteristicMetadata
                  union
                    select dataset_name
                    from panProtocolMetadata)),
        protocol_metadata
        as (select distinct organism, type, subtype, dataset_name, category, term, term_id, value
            from panProtocolMetadata),
        characteristic_metadata
        as (select distinct organism, type, subtype, dataset_name, category, term, term_id, value
            from panCharacteristicMetadata),
        metadata
        as (  select *
              from protocol_metadata
            union
              select *
              from characteristic_metadata),
        ontology_tree_metadata
        as (select distinct term_id, dataset_name, organism, type,subtype,
                            case
                              when lower(dataset_name) like '%microarrayantibody%'
                                   then 'Ontology_icemr_RSRC'
                              when lower(dataset_name) like 'otu%'
                                   then 'Ontology_microbiomeHierarchy_RSRC'
                              else null
                            end as hierarchy_dataset_name
            from PANCharacteristicMetadata
            where lower(dataset_name) like '%microarrayantibody%' or lower(dataset_name) like 'otu%'
           ),
        leaf_term
        as (select distinct term_id, hierarchy_dataset_name
            from ontology_tree_metadata
           ),
        graph_edge
        as (select ed.name as dataset_name, tree.* from (
            select subject_term_id as child_term_id, object_term_id as parent_term_id, external_database_release_id
            from sres.OntologyRelationship orel
            where external_database_release_id in (select edr.external_database_release_id
                                                   from sres.externaldatabase ed, sres.externaldatabaserelease edr
                                                   where ed.external_database_id = edr.external_database_id
                                                     and ed.name in ('Ontology_icemr_RSRC', 'Ontology_microbiomeHierarchy_RSRC')
                                                  )
              and orel.subject_term_id != orel.object_term_id
            start with subject_term_id in (select term_id from leaf_term)
            connect by subject_term_id = prior object_term_id) tree,
            sres.externaldatabase ed, 
            sres.externaldatabaserelease edr
            where tree.external_database_release_id = edr.external_database_release_id
            and ed.external_database_id = edr.external_database_id),
        unparented_term
        as (select parent_term_id as term_id, dataset_name from graph_edge
            minus
            select child_term_id as term_id, dataset_name from graph_edge),
        distinct_term
        as (select parent_term_id as term_id, dataset_name from graph_edge
            union
            select child_term_id as term_id, dataset_name from graph_edge),
        leaf_ancestor_pair 
        as (
        select ancestor.term_id as ancestor_term_id, descendent.term_id as leaf_term_id, ancestor.dataset_name
              from distinct_term ancestor, distinct_term descendent, leaf_term lt
              where descendent.term_id
                    in (select child_term_id
                        from graph_edge
                        start with parent_term_id = ancestor.term_id
                        connect by prior child_term_id = parent_term_id)
                and descendent.term_id = lt.term_id
                and decode(descendent.dataset_name, lt.hierarchy_dataset_name, 1 ,0) = 1 
                and descendent.dataset_name = ancestor.dataset_name
            union
              select term_id as ancestor_term_id, term_id as leaf_term_id, hierarchy_dataset_name as dataset_name
              from leaf_term
            ),
        fallback
        as (select distinct dataset_name, type, subtype, organism, hierarchy_dataset_name, term_name as property
            from FallbackMetadata
           )
        -- END OF WITH CLAUSES (whew!)
        -- parent
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, term as property, 'parent' as spec_property, category as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and hierarchy_dataset_name is null 
        -- leaf
        union
          select organism, m.dataset_name, type, subtype, hierarchy_dataset_name, term as property, 'leaf' as spec_property, 'true' as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
        -- filter
        union
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'filter' as spec_property, mt.filter as spec_value
          from metadata m, hierarchy_mapping hm, MetadataType mt
          where m.dataset_name = hm.dataset_name
            and m.term = mt.property
        -- display
        union
          select distinct organism, m.dataset_name, type, subtype,
                          hierarchy_dataset_name, term as property, 'display' as spec_property,
                          -- work around initcap's apostrophe problem
                          replace(replace(initcap(replace(term, '''', '4834929393')), '4834929393', ''''),
                                  '16s', '16S')
                            as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
        -- type
        union
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'type' as spec_property, mt.type as spec_value
          from metadata m, hierarchy_mapping hm, MetadataType mt
          where m.dataset_name = hm.dataset_name
            and m.term = mt.property
        union
        --description
          select m.organism, m.dataset_name, m.type, m.subtype, hm.hierarchy_dataset_name,
                 m.term as property, 'description' as spec_property, ot.definition as spec_value
          from metadata m, hierarchy_mapping hm, sres.ontologyterm ot
          where m.dataset_name = hm.dataset_name
            and m.term_id = ot.ontology_term_id
        -- parents: parent
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'parent' as spec_property, 'protocol' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'parent' as spec_property, 'characteristic' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- parents: display
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, category as property, 'display' as spec_property, category as spec_value
          from metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- grandparents: parent
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'protocol' as property, 'parent' as spec_property, '' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'characteristic' as property, 'parent' as spec_property, '' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        -- grandparents: display
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'protocol' as property, 'display' as spec_property, 'Protocol' as spec_value
          from protocol_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select distinct organism, m.dataset_name, type, subtype, hierarchy_dataset_name, 'characteristic' as property, 'display' as spec_property, 'Characteristic' as spec_value
          from characteristic_metadata m, hierarchy_mapping hm
          where m.dataset_name = hm.dataset_name
            and (hierarchy_dataset_name is null)
        union
          select otm.organism, otm.dataset_name, otm.type, subtype, otm.hierarchy_dataset_name,
                child.name as property, 'parent' as spec_property, parent.name as spec_value
          from ontology_tree_metadata otm, leaf_ancestor_pair lap,
               (select child_term_id, parent_term_id, dataset_name from graph_edge
                union
                select term_id as child_term_id, null as parent_term_id, dataset_name from unparented_term) edge,
               sres.OntologyTerm child, sres.OntologyTerm parent
          where edge.child_term_id = lap.ancestor_term_id
            and lap.leaf_term_id = otm.term_id
            and decode(lap.dataset_name, otm.hierarchy_dataset_name, 1 ,0) = 1
            and edge.child_term_id = child.ontology_term_id
            and edge.parent_term_id = parent.ontology_term_id(+)
            and decode(edge.dataset_name, otm.hierarchy_dataset_name, 1 ,0) = 1
        -- fallback: parent
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'parent' as spec_property, '' as spec_value
          from fallback
        -- fallback: display
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name,
                 property, 'display' as spec_property,
                  -- work around initcap's apostrophe problem:
                 replace(replace(initcap(replace(property, '''', '4834929393')), '4834929393', ''''),
                         '16s', '16S')
                   as spec_value
          from fallback
        -- fallback: filter
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'filter' as spec_property, 'membership' as spec_value
          from fallback
        -- fallback: leaf
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'leaf' as spec_property, 'true' as spec_value
          from fallback
        -- fallback: type
        union
          select organism, dataset_name, type, subtype, hierarchy_dataset_name, property, 'type' as spec_property, 'string' as spec_value
          from fallback
        ) 
        where dataset_name not in ('ISASimple_RSRC','ISA_RSRC')
        order by organism, dataset_name, property, spec_property, spec_value
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index msix1&1
        on MetadataSpec&1 (dataset_name, organism, hierarchy_dataset_name, property, spec_property, spec_value)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MetadataOntology">
    <comment>Wide, strongly-typed metadata ontology for new-style filter params
    </comment>
    <internalDependency name="MetadataSpec"/>
    <sql>
      <![CDATA[
        CREATE TABLE MetadataOntology&1 NOLOGGING AS
        SELECT SUBSTR(property, 1, 80) AS ontology_term_name,
               SUBSTR(parent_ontology_term_name, 1, 80) AS parent_ontology_term_name,
               SUBSTR(display_name, 1, 80) AS display_name, 
               SUBSTR(description, 1, 500) AS description,
               SUBSTR(units, 1, 40) AS units,
               SUBSTR(organism, 1, 80) AS organism,
               SUBSTR(dataset_name, 1, 80) AS dataset_name,
               SUBSTR(dataset_type, 1, 40) AS dataset_type,
               SUBSTR(subtype, 1, 40) AS subtype,
               CASE WHEN type IS NULL THEN 'string' ELSE SUBSTR(type, 1, 10) END AS type,
               CASE WHEN range = 'range' THEN 1 ELSE 0 END AS is_range, 
               CASE WHEN type = 'number' THEN 1 ELSE null END AS precision
        FROM (SELECT DISTINCT property, spec_property, spec_value, organism, dataset_name, subtype, type as dataset_type
              FROM MetadataSpec)
        PIVOT (MAX(spec_value)
               FOR spec_property
                 IN ('parent' AS parent_ontology_term_name, 'display' AS display_name,
                     'description' as description, 'type' as type, 'units' as units,
                     'filter' as range, 'categorized' as is_categorized))
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index moix1&1
        on MetadataOntology&1 (dataset_name, organism, ontology_term_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="TaxonAbundanceSpec">
    <internalDependency name="TaxonAbundance"/>
    <sql>
      <![CDATA[
       create table TaxonAbundanceSpec&1 nologging as

        -- parent
          select  type, subtype, dataset_name,  term_id as property, 'parent' as spec_property, category as spec_value
          from TaxonAbundance
        --grandparent
        union
          select  type, subtype, dataset_name, category as property, 'parent' as spec_property, null as spec_value
          from TaxonAbundance
        -- leaf
        union
          select type, subtype, dataset_name,  term_id as property, 'leaf' as spec_property, 'true' as spec_value
          from TaxonAbundance
        -- filter
        union
          select type, subtype, dataset_name,
                 term_id as property, 'filter' as spec_property, 'range' as spec_value
          from TaxonAbundance
        -- display
        union
          select distinct type, subtype, dataset_name, term_id as property, 'display' as spec_property, term as spec_value
          from TaxonAbundance
        -- parent:display
        union
          select distinct type, subtype, dataset_name, category as property, 'display' as spec_property, category as spec_value
          from TaxonAbundance
        -- type
        union
          select type, subtype, dataset_name, term_id as property, 'type' as spec_property, 'number' as spec_value
          from TaxonAbundance
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProjectTaxon" prefixEnabled="true">
    <comment>map taxon names to project_ids. to be used by the apidb.project_id function</comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="apidb.Organism"/>
    <sql>
      <![CDATA[
        create table &prefixProjectTaxon&1 nologging as
        with
          local_taxon /* a taxon found in this instance, either in dots.ExternalNaSequence or in apidb.Organism */
          as (  select distinct tn.name as taxon,
                       substr((tn.name), 1, instr(tn.name||' ', ' ') - 1) as first_word,
                       pi.name as project_id
                from dots.ExternalNaSequence ens, sres.TaxonName tn, core.ProjectInfo pi
                where ens.taxon_id = tn.taxon_id
                  and tn.name_class = 'scientific name' 
                  and ens.row_project_id = pi.project_id
              /* get names from apidb.Organism.family_name_for_files
                 (may not be necessary) */
              union
                select family_name_for_files as taxon,
                       substr((family_name_for_files), 1, instr(family_name_for_files||' ', ' ') - 1) as first_word,
                       project_name as project_id
                from apidb.Organism
                where family_name_for_files in (select name from sres.TaxonName)
                ),
          mononym /* a taxon name that's the first word of a local taxon */
          as (select distinct lower(lt.first_word) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.first_word = tn.name
                and tn.name_class = 'scientific name'),
          full_name /* the full name of a local taxon whose first name is not a taxon */
          as (select distinct lower(lt.taxon) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.taxon = tn.name
                and tn.name_class = 'scientific name'
                and lower(lt.first_word) not in (select taxon from mononym))
          select * from mononym
        union
          select * from full_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index data_load_prjct_error&1 on &prefixProjectTaxon&1 (taxon)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index projtax_ix&1 on &prefixProjectTaxon&1 (taxon, project_id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <comment>Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         GenomicSeqAttributes, and SimilaritySpanLocation
     </comment>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSeqAttributes" prefixEnabled="true">
    <comment>Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSeqAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.external_database_release_id, sequence.sequence_ontology_id,
       sequence.chromosome_order_num, so.source_id as so_id, so.name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id, organism.genome_source,
       organism.name_for_filenames, nvl(msa.has_msa, 0) as has_msa
FROM sres.TaxonName tn, sres.Taxon, sres.OntologyTerm so, apidb.Organism,
     ( select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.VirtualSequence) sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization,
     (SELECT a_na_sequence_id as na_sequence_id, 1 as has_msa
      FROM apidb.Synteny syn
      GROUP BY a_na_sequence_id) msa
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.ontology_term_id
  AND so.name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id(+)
  AND sequence.na_sequence_id = msa.na_sequence_id(+)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixGenomicSeqAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixGenomicSeqAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixGenomicSeqAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SampleAttributes" alwaysUpdate="true">
    <comment>lots of columns for sample meta data. used for sample record
      </comment>
    <program commandLine="buildSampleAttributesTT"/>
  </tuningTable>


  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <comment> Data for a dataset. Used widely in the model, and by GBrowse.</comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetProperty"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <ancillaryTable name="DatasetHistory"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="EupathBuildDates" alwaysUpdate="true">
    <program commandLine="buildEupathBuildDatesTT"/>
  </tuningTable>


  <tuningTable name="DatasetDetail" alwaysUpdate="true">
    <comment> Stores text associated with each dataset. Used by dataset queries.
      </comment>
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      create table DatasetDetail&1 nologging
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from DatasetPresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(dpub.citation, '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from DatasetPresenter dp, DatasetContact dc, 
           DatasetPublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="ExternalDbDatasetPresenter">
    <comment>
      A materialization of the oft-computed join of sres.externalDatabaseRelease,
      sres.externalDatabase, and DatasetPresenter.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExternalDbDatasetPresenter&1 NOLOGGING AS
        SELECT ed.external_database_id, ed.name AS external_database_name,
               edr.external_database_release_id, SUBSTR(edr.version, 1, 40) AS external_database_version,
               dsp.dataset_presenter_id, dsp.name AS dataset_presenter_name,
               dsp.display_name AS dataset_presenter_display_name
        FROM sres.externalDatabaseRelease edr,  sres.externalDatabase ed, DatasetPresenter dsp
        WHERE ed.external_database_id = edr.external_database_id
          AND (ed.name = dsp.name
               OR ed.name LIKE dsp.dataset_name_pattern)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_rlsidix&1
          on ExternalDbDatasetPresenter&1
            (external_database_release_id, external_database_id, external_database_name,
             dataset_presenter_id, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsidix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_id, external_database_id, external_database_release_id, 
             external_database_name, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsnameix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_name, dataset_presenter_id, external_database_id, 
             external_database_release_id, external_database_name, external_database_version, 
             dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="MetadataType">
    <comment>
       Data type and filter method for metadata properties.
    </comment>
    <internalDependency name="PANProtocolMetadata"/>
    <sql>
      <![CDATA[
        CREATE TABLE MetadataType&1 NOLOGGING AS
        WITH override
        AS ( SELECT 'age' AS property, 'number' AS type, 'range' AS filter FROM dual
            UNION
              SELECT 'name' AS property, 'string' AS type, 'membership' AS filter FROM dual
            union   
              SELECT 'studyid' AS property, 'string' AS type, 'membership' AS filter FROM dual
           union   
              SELECT 'taxon_id' AS property, 'number' AS type, 'membership' AS filter FROM dual
          union
             SELECT 'proportion mapped reads' AS property, 'number' AS type, 'range' AS filter FROM dual
           ),
        metadata
        AS (  SELECT term, value
              FROM panProtocolMetadata
              WHERE term NOT IN (SELECT property FROM override)
            UNION
              SELECT term, value
              FROM panCharacteristicMetadata
              WHERE term NOT IN (SELECT property FROM override)
           ),
        term_attributes
        AS (SELECT term,
                   -- IS_NUMBER() returns 0 or 1. Flip its value by subtracting from 1
                   MAX(1 - apidb.is_number(value)) AS is_string
            FROM metadata
            GROUP BY term
           )
     SELECT * FROM override
 UNION ALL
   SELECT term AS property,
          CASE is_string
            WHEN 1
              THEN 'string'
            ELSE 'number'
          END AS type,
          CASE is_string
            WHEN 1
              THEN 'membership'
            ELSE 'range' 
          END AS filter
   FROM term_attributes
       ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX mtdprop_ix&1
          ON MetadataType&1 (property)
        TABLESPACE indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE INDEX mtdttyp_ix&1
          ON MetadataType&1 (property, type, filter)
        TABLESPACE indx
      ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonRelativeAbundance">
    <comment>for the sample record taxon relative abundance table
     </comment>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="apidb.SequenceTaxon"/>
    <externalDependency name="results.OtuAbundance"/>
    <internalDependency name="PANProtocolMetadata"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        create table TaxonRelativeAbundance&1
            (name, protocol_app_node_id, taxon_id, relative_abundance, 
             absolute_abundance, ncbi_tax_id, kingdom, phylum, class, 
             rank_order, family, genus, species,
             constraint taxRelAbund&1_pk primary key(name, taxon_id))
        organization index
        nologging
        as select ta.*, t.ncbi_tax_id,
                  replace(decode(superkingdom, 'N/A', kingdom, superkingdom), 'N/A', '') as kingdom,
                  replace(phylum, 'N/A', '') as phylum,
                  replace(class, 'N/A', '') as class,
                  replace(rank_order, 'N/A', '') as rank_order,
                  replace(family, 'N/A', '') as family,
                  replace(genus, 'N/A', '') as genus,
                  replace(species, 'N/A', '') as species
           from (select ds.name, oa.protocol_app_node_id, taxonAssignment.taxon_id,
                        sum(nvl(oa.relative_abundance, 0)) as relative_abundance,
                        sum(nvl(oa.raw_count, 0)) as absolute_abundance
                 from results.OtuAbundance oa, SampleDownstream ds,
                      (select ens.na_sequence_id,
                              case
                                when st.taxon_id is not null
                                  then st.taxon_id
                                else ens.taxon_id
                              end as taxon_id,
                              case
                                when st.taxon_id is not null
                                  then 'Greengenes'
                                else 'Genbank'
                              end as source
                       from dots.ExternalNaSequence ens, apidb.SequenceTaxon st
                       where ens.na_sequence_id = st.na_sequence_id(+)
                       ) taxonAssignment
                 where oa.protocol_app_node_id = ds.output_protocol_app_node_id
                   and ds.output_isa_type = 'Data'
                   and oa.na_sequence_id = taxonAssignment.na_sequence_id
                 group by ds.name, oa.protocol_app_node_id, taxonAssignment.taxon_id
                ) ta,
                ExternalSequenceTaxonRank estr, sres.Taxon t
           where ta.taxon_id = estr.organism
             and ta.relative_abundance > 0
             and ta.taxon_id = t.taxon_id
      ]]>
    </sql>
  </tuningTable>

</tuningConfig>
