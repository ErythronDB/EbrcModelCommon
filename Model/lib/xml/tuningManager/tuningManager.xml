<?xml version="1.0" encoding="UTF-8"?>
<tuningConfig>

  <import file="studyTuningManager.xml"/>

  <tuningTable name="ExternalSequenceTaxonRank" prefixEnabled="false">
    <comment>Taxon ranks for 16S reference organisms                                                                                                     
    </comment>
    <externalDependency name="apidb.TaxonString"/>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="sres.Taxon"/>
    <sql>
      <![CDATA[
create table ExternalSequenceTaxonRank&1 nologging as
with organism_rank
     as (select tn1.taxon_id as organism, tn2.name as parent_organism, 
                tn2.taxon_id as parent_organism_id, r.rank
         from sres.TaxonName tn1, sres.TaxonName tn2,
              (select CONNECT_BY_ROOT taxon_id as input, taxon_id, rank
               from sres.taxon
               start with taxon_id in (  select taxon_id from DOTS.EXTERNALNASEQUENCE
                                       union
                                         select taxon_id from apidb.TaxonString)
               connect by prior parent_id = taxon_id) r
         where r.input = tn1.taxon_id
           and r.taxon_id = tn2.taxon_id
           and tn1.name_class = 'scientific name'
           and tn2.name_class = 'scientific name'
           and r.rank in ('phylum', 'family','genus', 'species', 'superkingdom','kingdom', 'class', 'order')
        )
select organisms.organism, 
       nvl(superkingdom.parent_organism, 'N/A') as superkingdom,
       superkingdom.parent_organism_id as superkingdom_id,
       nvl(kingdom.parent_organism, 'N/A') as kingdom,
       kingdom.parent_organism_id as kingdom_id,
       nvl (phylum.parent_organism, 'N/A') as phylum,
       phylum.parent_organism_id as phylum_id,
       nvl (class.parent_organism, 'N/A') as class,
       class.parent_organism_id as class_id,
       nvl (family.parent_organism, 'N/A') as family,
       family.parent_organism_id as family_id,
       nvl (rank_order.parent_organism, 'N/A') as rank_order,
       rank_order.parent_organism_id as rank_order_id,
       nvl ( genus.parent_organism, 'N/A') as genus,
       genus.parent_organism_id as genus_id,
       nvl(species.parent_organism, 'N/A') as species,
       species.parent_organism_id as species_id
from (select distinct organism from organism_rank) organisms,
     (select * from organism_rank where rank= 'phylum') phylum,
     (select * from organism_rank where rank= 'genus') genus,
     (select * from organism_rank where rank= 'species') species,
     (select * from organism_rank where rank= 'kingdom') kingdom,
     (select * from organism_rank where rank= 'superkingdom') superkingdom,
     (select * from organism_rank where rank= 'class') class,
     (select * from organism_rank where rank= 'family') family,
     (select * from organism_rank where rank= 'order') rank_order
where organisms.organism = phylum.organism (+)
  and organisms.organism = genus.organism (+)
  and organisms.organism = species.organism (+)
  and organisms.organism = kingdom.organism (+)
  and organisms.organism = class.organism (+)
  and organisms.organism = rank_order.organism (+)
  and organisms.organism = family.organism (+)
  and organisms.organism = superkingdom.organism (+)
order by organism, species, genus
       ]]>
    </sql>
  </tuningTable>

  <tuningTable name="TaxonAbundance" prefixEnabled="false">
    <comment>otu relative abundance values, aggegated at various taxonomic levels
    </comment>
    <externalDependency name="apidb.Datasource"/>
    <externalDependency name="results.OtuAbundance"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="study.ProtocolAppNode"/>
    <externalDependency name="study.Study"/>
    <externalDependency name="study.StudyLink"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        CREATE TABLE TaxonAbundance&1 NOLOGGING AS
        WITH leaf_abundance
        AS (SELECT oa.protocol_app_node_id, oa.raw_count AS raw_count,
                   oa.relative_abundance AS relative_abundance, 
                   oa.taxon_id as taxon_id
            FROM results.OtuAbundance oa
            WHERE oa.relative_abundance is not null
           ),
        taxa_string_map
        AS (  SELECT DECODE(REPLACE(estr.kingdom, 'N/A', 'unknown'), 'unknown',
                            REPLACE(estr.superkingdom, 'N/A', 'unknown'), estr.kingdom) AS taxon_string
                     , 'kingdom' AS taxon_node
                     , nvl(kingdom_id, superkingdom_id) AS taxon_id
                     , 1 AS taxon_level
                     , la.protocol_app_node_id
                     , la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.phylum, 'N/A', 'unknown') AS taxon_string
                     , 'phylum' AS taxon_node
                     , phylum_id AS taxon_id
                     , 2 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT REPLACE(estr.class, 'N/A', 'unknown') AS taxon_string
                     , 'class' AS taxon_node
                     , class_id AS taxon_id
                     , 3 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.rank_order, 'N/A', 'unknown')as taxon_string
                     , 'order' AS taxon_node
                     , rank_order_id AS taxon_id
                     , 4 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.family, 'N/A', 'unknown') AS taxon_string
                     , 'family' AS taxon_node
                     , family_id AS taxon_id
                     , 5 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
                FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.genus, 'N/A', 'unknown') AS taxon_string
                     , 'genus' AS taxon_node
                     , genus_id AS taxon_id
                     , 6 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
            UNION
              SELECT replace(estr.species, 'N/A', 'unknown') AS taxon_string
                     , 'species' AS taxon_node
                     , species_id AS taxon_id
                     , 7 AS taxon_level
                     , la.protocol_app_node_id,la.relative_abundance
                     , la.raw_count
              FROM ExternalSequenceTaxonRank estr, leaf_abundance la
              WHERE estr.organism = la.taxon_id
           ),
        agg_taxon_string_map
        AS (SELECT taxon_string AS taxon_name, taxon_node,
                   taxon_node || '|' || taxon_id AS taxon_id, taxon_level,
                   protocol_app_node_id, SUM(relative_abundance) AS relative_abundance,
                   SUM(raw_count) AS raw_count
            FROM taxa_string_map
            GROUP BY taxon_string, taxon_node, taxon_node || '|' || taxon_id,
                     taxon_level, protocol_app_node_id
           )
        SELECT tsm.protocol_app_node_id, pan.name AS pan_name,
               initcap(tsm.taxon_node) AS category, CAST(tsm.taxon_name AS VARCHAR2(200)) AS term,
               tsm.taxon_id AS term_id, ds.name AS dataset_name, ds.type, ds.subtype,
               study_release.study_name, study_release.investigation_name,
               tsm.taxon_level, tsm.raw_count AS agg_count,
               round(tsm.relative_abundance, 6) AS value
        FROM agg_taxon_string_map tsm,
             study.ProtocolAppNode pan,
             study.StudyLink sl,
             sres.ExternalDatabaseRelease edr,
             sres.ExternalDatabase ed,
             apidb.Datasource ds,
             (SELECT s.study_id, i.external_database_release_id,
                     s.name AS study_name, i.name AS investigation_name
              FROM study.Study s, study.Study i
              WHERE s.investigation_id = i.study_id
                AND s.name not like '%[%]%'
                AND i.name like 'OTU Profile%'
              ) study_release
        WHERE tsm.protocol_app_node_id = pan.protocol_app_node_id
          AND tsm.protocol_app_node_id = sl.protocol_app_node_id
          AND sl.study_id = study_release.study_id
          AND study_release.external_database_release_id = edr.external_database_release_id
          AND edr.external_database_id = ed.external_database_id
          AND ed.name = ds.name
        ORDER BY type, subtype, study_name, dataset_name, pan_name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        CREATE UNIQUE INDEX TaxAbund_panId_Term&1
          ON TaxonAbundance&1 (protocol_app_node_id, term_id,  category, term)
          TABLESPACE INDX
      ]]>
    </sql>
  </tuningTable>








  <tuningTable name="TaxonAbundanceSpec">
    <internalDependency name="TaxonAbundance"/>
    <sql>
      <![CDATA[
       create table TaxonAbundanceSpec&1 nologging as
        -- parent
          select  type, subtype, dataset_name,  term_id as property, 'parent' as spec_property, category as spec_value, taxon_level
          from TaxonAbundance
        --grandparent
        union
          select  type, subtype, dataset_name, category as property, 'parent' as spec_property, null as spec_value, taxon_level
          from TaxonAbundance
        -- leaf
        union
          select type, subtype, dataset_name,  term_id as property, 'leaf' as spec_property, 'true' as spec_value, taxon_level
          from TaxonAbundance
        -- filter
        union
          select type, subtype, dataset_name,
                 term_id as property, 'filter' as spec_property, 'range' as spec_value, taxon_level
          from TaxonAbundance
        -- display
        union
          select distinct type, subtype, dataset_name, term_id as property, 'display' as spec_property, term as spec_value, taxon_level
          from TaxonAbundance
        -- parent:display
        union
          select distinct type, subtype, dataset_name, category as property, 'display' as spec_property, category as spec_value, taxon_level
          from TaxonAbundance
        -- type
        union
          select type, subtype, dataset_name, term_id as property, 'type' as spec_property, 'number' as spec_value, taxon_level
          from TaxonAbundance
        order by 1, 2, 3
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="ProjectTaxon" prefixEnabled="true">
    <comment>map taxon names to project_ids. to be used by the apidb.project_id function</comment>
    <externalDependency name="dots.ExternalNaSequence"/>
    <externalDependency name="sres.TaxonName"/>
    <externalDependency name="core.ProjectInfo"/>
    <externalDependency name="apidb.Organism"/>
    <sql>
      <![CDATA[
        create table &prefixProjectTaxon&1 nologging as
        with
          local_taxon /* a taxon found in this instance, either in dots.ExternalNaSequence or in apidb.Organism */
          as (  select distinct tn.name as taxon,
                       substr((tn.name), 1, instr(tn.name||' ', ' ') - 1) as first_word,
                       pi.name as project_id
                from dots.ExternalNaSequence ens, sres.TaxonName tn, core.ProjectInfo pi
                where ens.taxon_id = tn.taxon_id
                  and tn.name_class = 'scientific name' 
                  and ens.row_project_id = pi.project_id
              /* get names from apidb.Organism.family_name_for_files
                 (may not be necessary) */
              union
                select family_name_for_files as taxon,
                       substr((family_name_for_files), 1, instr(family_name_for_files||' ', ' ') - 1) as first_word,
                       project_name as project_id
                from apidb.Organism
                where family_name_for_files in (select name from sres.TaxonName)
                ),
          mononym /* a taxon name that's the first word of a local taxon */
          as (select distinct lower(lt.first_word) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.first_word = tn.name
                and tn.name_class = 'scientific name'),
          full_name /* the full name of a local taxon whose first name is not a taxon */
          as (select distinct lower(lt.taxon) as taxon, lt.project_id
              from local_taxon lt, sres.TaxonName tn
              where lt.taxon = tn.name
                and tn.name_class = 'scientific name'
                and lower(lt.first_word) not in (select taxon from mononym))
          select * from mononym
        union
          select * from full_name
        order by 2, 1
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index data_load_prjct_err&1 on &prefixProjectTaxon&1 (taxon)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create unique index projtax_ix&1 on &prefixProjectTaxon&1 (taxon, project_id)
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="SequencePieceClosure" prefixEnabled="true">
    <comment>Extends dots.SequencePiece to handle multiple levels. Used in
         sequence-record queries and in other tuning tables, including
         GenomicSeqAttributes, and SimilaritySpanLocation
     </comment>
    <externalDependency name="dots.SequencePiece"/>
    <sql>
      <![CDATA[
        create table &prefixSequencePieceClosure&1 nologging as
        select sp.sequence_piece_id,
               sp.virtual_na_sequence_id,
               sp.piece_na_sequence_id, 
               sp.sequence_order, 
               sp.distance_from_left,
               sp.uncertainty,
               sp.strand_orientation,
               sp.start_position,
               sp.end_position, 
               sp.modification_date,
               1 as edge_level
        from dots.SequencePiece sp, dots.NaSequence ns
        where sp.piece_na_sequence_id = ns.na_sequence_id
          and (ns.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
      ]]>
    </sql>
    <sql>
      <![CDATA[
        /* known issue: this should be run not just once, but iteratively
           until it doesn't create new records.  Currently (7/2008),
           SequencePieces aren't nested even once. */
        insert into &prefixSequencePieceClosure&1
                    (edge_level, virtual_na_sequence_id, piece_na_sequence_id,
                     distance_from_left, strand_orientation, modification_date, 
                     start_position, end_position, sequence_order, sequence_piece_id)
        select 2, higher.virtual_na_sequence_id, lower.piece_na_sequence_id,
               higher.distance_from_left,
               case
                 when nvl(higher.strand_orientation, '+') = nvl(lower.strand_orientation, '+')
                 then '+'
                 else '-'
               end as strand_orientation,
               sysdate,
               higher.start_position - lower.distance_from_left, 
               higher.end_position - lower.distance_from_left, 
               higher.sequence_order,
               dots.sequencepiece_sq.nextval
        from &prefixSequencePieceClosure&1 higher, &prefixSequencePieceClosure&1 lower
        where higher.piece_na_sequence_id = lower.virtual_na_sequence_id
         and higher.start_position >= lower.start_position + lower.distance_from_left
         and higher.end_position <= lower.end_position + lower.distance_from_left
      ]]>
    </sql>
  </tuningTable>


  <tuningTable name="GenomicSeqAttributes" prefixEnabled="true">
    <comment>Each row represents one genomic sequence for which a WDK sequence
         record can be instantiated. Used widely in the workflow, the model,
         and GBrowse, as well as in the creation of a dozen or so other tuning
         tables.
    </comment>
    <internalDependency name="ProjectTaxon"/>
    <internalDependency name="SequencePieceClosure"/>
    <externalDependency name="apidb.Synteny"/>
    <externalDependency name="apidb.Organism"/>
    <externalDependency name="dots.DbRefNaSequence"/>
    <externalDependency name="sres.DbRef"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <externalDependency name="sres.OntologyTerm"/>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="sres.TaxonName"/>
    <sql>
      <![CDATA[
CREATE TABLE &prefixGenomicSeqAttributes&1 NOLOGGING AS
SELECT cast(apidb.prefixed_project_id(tn.name, '&prefix') as varchar2(20)) as project_id,
       SUBSTR(sequence.source_id, 1, 60) AS source_id, sequence.a_count,
       sequence.c_count, sequence.g_count, sequence.t_count,
       (sequence.length
        - (sequence.a_count + sequence.c_count + sequence.g_count + sequence.t_count))
         AS other_count,
       sequence.length,
       to_char((sequence.a_count + sequence.t_count) / sequence.length * 100, '99.99')
         AS at_percent,
       SUBSTR(tn.name, 1, 100) AS organism,
       taxon.ncbi_tax_id,
       taxon.taxon_id,                 
       CASE WHEN sequence.description IS NULL  THEN SUBSTR(tn.name, 1, 100)
            ELSE SUBSTR(sequence.description, 1, 400)
            END AS sequence_description,
       SUBSTR(genbank.genbank_accession, 1, 20) AS genbank_accession,
       SUBSTR(db.database_version, 1, 30) AS database_version, db.database_name,
       SUBSTR(sequence.chromosome, 1, 20) AS chromosome,
       sequence.external_database_release_id, sequence.sequence_ontology_id,
       sequence.chromosome_order_num, so.source_id as so_id, so.name as sequence_type,
       nvl(virtualization.is_top_level, 1) as is_top_level,
       sequence.na_sequence_id, organism.genome_source,
       organism.name_for_filenames, nvl(msa.has_msa, 0) as has_msa
FROM sres.TaxonName tn, sres.Taxon, sres.OntologyTerm so, apidb.Organism,
     ( select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.ExternalNaSequence
      union
       select na_sequence_id, source_id, length, chromosome, chromosome_order_num, taxon_id, description,
              a_count, c_count, g_count, t_count, external_database_release_id, sequence_ontology_id
       from dots.VirtualSequence) sequence,
     (SELECT drns.na_sequence_id, max(dr.primary_identifier) AS genbank_accession
      FROM dots.dbrefNaSequence drns, sres.DbRef dr,
           sres.ExternalDatabaseRelease gb_edr, sres.ExternalDatabase gb_ed
      WHERE drns.db_ref_id = dr.db_ref_id
        AND dr.external_database_release_id
            = gb_edr.external_database_release_id
        AND gb_edr.external_database_id = gb_ed.external_database_id
        AND gb_ed.name = 'GenBank'
      GROUP BY drns.na_sequence_id) genbank,
     (SELECT edr.external_database_release_id,
             edr.version AS database_version, ed.name AS database_name
      FROM sres.ExternalDatabase ed, sres.ExternalDatabaseRelease edr
      WHERE edr.external_database_id = ed.external_database_id) db,
     (SELECT distinct piece_na_sequence_id, 0 as is_top_level
      FROM &prefixSequencePieceClosure) virtualization,
     (SELECT a_na_sequence_id as na_sequence_id, 1 as has_msa
      FROM apidb.Synteny syn
      GROUP BY a_na_sequence_id) msa
WHERE sequence.taxon_id = tn.taxon_id(+)
  AND (sequence.taxon_id = '&filterValue' or nvl('&filterValue', 0) = 0)
  AND tn.name_class = 'scientific name'
  AND sequence.taxon_id = taxon.taxon_id
  AND sequence.sequence_ontology_id = so.ontology_term_id
  AND so.name IN ('random_sequence', 'chromosome', 'contig', 'supercontig','mitochondrial_chromosome','plastid_sequence','cloned_genomic','apicoplast_chromosome')
  AND sequence.na_sequence_id = genbank.na_sequence_id(+)
  AND sequence.external_database_release_id = db.external_database_release_id(+)
  AND sequence.na_sequence_id = virtualization.piece_na_sequence_id(+)
  AND taxon.taxon_id = organism.taxon_id(+)
  AND sequence.na_sequence_id = msa.na_sequence_id(+)
ORDER BY organism, source_id
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index pk_SeqAttr_&1 ON &prefixGenomicSeqAttributes&1 (lower(source_id), project_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_source_id&1 ON &prefixGenomicSeqAttributes&1 (source_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
create unique index SeqAttr_naseqid&1 ON &prefixGenomicSeqAttributes&1 (na_sequence_id)
      ]]>
    </sql>
  </tuningTable>




  <tuningTable name="DatasetPresenter" alwaysUpdate="true">
    <comment> Data for a dataset. Used widely in the model, and by GBrowse.</comment>
    <internalDependency name="GenomicSeqAttributes"/>
    <ancillaryTable name="DatasetContact"/>
    <ancillaryTable name="DatasetProperty"/>
    <ancillaryTable name="DatasetHyperLink"/>
    <ancillaryTable name="DatasetPublication"/>
    <ancillaryTable name="DatasetModelRef"/>
    <ancillaryTable name="DatasetNameTaxon"/>
    <ancillaryTable name="DatasetHistory"/>
    <program commandLine="buildDatasetPresentersTT"/>
  </tuningTable>


  <tuningTable name="EupathBuildDates" alwaysUpdate="true">
    <internalDependency name="GenomicSeqAttributes"/>
    <program commandLine="buildEupathBuildDatesTT"/>
  </tuningTable>


  <tuningTable name="DatasetDetail" alwaysUpdate="true">
    <comment> Stores text associated with each dataset. Used by dataset queries.
      </comment>
    <internalDependency name="DatasetPresenter"/>
    <sql>
      <![CDATA[
      create table DatasetDetail&1 nologging
      as
            select dataset_presenter_id, 
      name||' '||category||' '||usage||' '|| 
      caveat||' '||acknowledgement||' '||type||' '||subtype
      ||' '| |summary||' '||description||' '||contact||' '||
      institution||' '||pubmed_id||' '||citation as search_string
      from (
      select
      sub.dataset_presenter_id as dataset_presenter_id, 
      sub.name as name, 
      sub.category as category,
      sub.usage as usage, 
      sub.caveat as caveat,
      sub.acknowledgement as acknowledgement, 
      sub.type as type, 
      sub.subtype as subtype,
      sub.contact,
      sub.institution,
      sub.pubmed_id,
      sub.citation,
      dp.summary,
      dp.description
      from DatasetPresenter dp,
      (
      select distinct
      dp.dataset_presenter_id as dataset_presenter_id, 
      dp.display_name as name, 
      dp.display_category as category,
      dp.usage as usage, 
      dp.caveat as caveat,
      dp.acknowledgement as acknowledgement, 
      dp.type as type, 
      dp.subtype as subtype, 
      dc.name as contact,
      dc.affiliation as institution,
      LISTAGG(dpub.pmid, ' ') WITHIN GROUP (ORDER BY dpub.pmid) as pubmed_id,
      LISTAGG(CASE WHEN REGEXP_LIKE(dpub.citation, '[[:digit:]]{4};')
                   THEN substr(citation, 1, regexp_instr(citation, '[[:digit:]]{4};' ) - 1)
                   ELSE dpub.citation
              END , '  ') WITHIN GROUP (ORDER BY dpub.citation) as citation
      from DatasetPresenter dp, DatasetContact dc, 
           DatasetPublication dpub  
      where dp.dataset_presenter_id = dc.dataset_presenter_id
      and   dp.dataset_presenter_id = dpub.dataset_presenter_id
      and   dc.is_primary_contact = 1
      group by dp.dataset_presenter_id, dp.display_name,dp.display_category,
               dp.usage,dp.caveat,dp.acknowledgement,dp.type,dp.subtype,dc.name,
               dc.affiliation
      ) sub
      
      where dp.dataset_presenter_id = sub.dataset_presenter_id)
      ]]>
    </sql>
    <sql>
      <![CDATA[
          CREATE INDEX DATASET_DETAIL_IDX&1 ON DATASETDETAIL&1 (search_string)
          INDEXTYPE IS CTXSYS.CONTEXT
      ]]>
    </sql>

  </tuningTable>


  <tuningTable name="ExternalDbDatasetPresenter">
    <comment>
      A materialization of the oft-computed join of sres.externalDatabaseRelease,
      sres.externalDatabase, and DatasetPresenter.
    </comment>
    <internalDependency name="DatasetPresenter"/>
    <externalDependency name="sres.ExternalDatabase"/>
    <externalDependency name="sres.ExternalDatabaseRelease"/>
    <sql>
      <![CDATA[
        CREATE TABLE ExternalDbDatasetPresenter&1 NOLOGGING AS
        SELECT ed.external_database_id, ed.name AS external_database_name,
               edr.external_database_release_id, SUBSTR(edr.version, 1, 40) AS external_database_version,
               dsp.dataset_presenter_id, dsp.name AS dataset_presenter_name,
               dsp.display_name AS dataset_presenter_display_name
        FROM sres.externalDatabaseRelease edr,  sres.externalDatabase ed, DatasetPresenter dsp
        WHERE ed.external_database_id = edr.external_database_id
          AND (ed.name = dsp.name
               OR ed.name LIKE dsp.dataset_name_pattern)
        ORDER BY ed.name
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_rlsidix&1
          on ExternalDbDatasetPresenter&1
            (external_database_release_id, external_database_id, external_database_name,
             dataset_presenter_id, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsidix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_id, external_database_id, external_database_release_id, 
             external_database_name, dataset_presenter_name, dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
    <sql>
      <![CDATA[
        create index edd_dsnameix&1
          on ExternalDbDatasetPresenter&1
            (dataset_presenter_name, dataset_presenter_id, external_database_id, 
             external_database_release_id, external_database_name, external_database_version, 
             dataset_presenter_display_name)
        tablespace indx
      ]]>
    </sql>
  </tuningTable>



  <tuningTable name="TaxonRelativeAbundance">
    <comment>for the sample record taxon relative abundance table
     </comment>
    <externalDependency name="sres.Taxon"/>
    <externalDependency name="results.OtuAbundance"/>
    <internalDependency name="InferredParams"/>
    <internalDependency name="ExternalSequenceTaxonRank"/>
    <sql>
      <![CDATA[
        create table TaxonRelativeAbundance&1
            (name, protocol_app_node_id, taxon_id, relative_abundance, 
             absolute_abundance, ncbi_tax_id, kingdom, phylum, class, 
             rank_order, family, genus, species,
             constraint taxRelAbund&1_pk primary key(name, taxon_id))
        organization index
        nologging
        as select ta.*, t.ncbi_tax_id,
                  replace(decode(superkingdom, 'N/A', kingdom, superkingdom), 'N/A', '') as kingdom,
                  replace(phylum, 'N/A', '') as phylum,
                  replace(class, 'N/A', '') as class,
                  replace(rank_order, 'N/A', '') as rank_order,
                  replace(family, 'N/A', '') as family,
                  replace(genus, 'N/A', '') as genus,
                  replace(species, 'N/A', '') as species
           from (select ds.name, oa.protocol_app_node_id, oa.taxon_id,
                        sum(nvl(oa.relative_abundance, 0)) as relative_abundance,
                        sum(nvl(oa.raw_count, 0)) as absolute_abundance
                 from results.OtuAbundance oa, sampleprocess ds
                 where oa.protocol_app_node_id = ds.output_pan_id
                   and ds.output_isa_type = 'Data'
                 group by ds.name, oa.protocol_app_node_id, oa.taxon_id
                ) ta,
                ExternalSequenceTaxonRank estr, sres.Taxon t
           where ta.taxon_id = estr.organism
             and ta.relative_abundance > 0
             and ta.taxon_id = t.taxon_id
      ]]>
    </sql>
  </tuningTable>


</tuningConfig>
