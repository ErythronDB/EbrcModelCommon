#!/usr/bin/perl

use strict;

use lib "$ENV{GUS_HOME}/lib/perl";

use DBI;
use DBD::Oracle;

use Getopt::Long qw(GetOptions);

use EbrcModelCommon::Model::tmUtils;

my ($help, $propfile, $instance, $schema, $suffix, $debug);

GetOptions("propfile=s" => \$propfile,
           "instance=s" => \$instance,
           "schema=s" => \$schema,
           "suffix=s" => \$suffix,
           "debug!" => \$debug,
           "help|h" => \$help,
          );

die "required parameter missing" unless ($propfile && $instance && $suffix);

my $dbh = EbrcModelCommon::Model::tmUtils::getDbHandle($instance, $schema, $propfile);

&run();

sub run{

  if($help) {
    &usage();
  }

  my $failures = 0;

  my %types = ("Participant" => "Participant",
               "Event" => "Event",
               "CDC light trap assay" => "LightTrap",
               "Household" => "Household",
               "Specimen" => "Sample",
      );


  foreach my $type (keys %types) {
    my $record = $types{$type};

    # for SampleAttributes, we cannot rely on the type_id.  (lots of more specific types of samples like "blood specimen" ...)
    my $orIsaSample = $record eq 'Sample' ? "or protocol_app_node_isa_type = 'Sample'" : "";

    my (@fields);
    my $fieldsSh = $dbh->prepare(<<SQL);
    -- turn terms into column names
      select distinct term, type
      from (  select mt.source_id as term, mt.type
              from PANCHARACTERISTICMETADATA m, MetaDataType mt where mt.term_id = m.term_id and (protocol_app_node_type = '$type' $orIsaSample)
            union
              select mt.source_id as term, mt.type
              from PANPROTOCOLMETADATA m, MetaDataType mt  where mt.term_id = m.term_id and (protocol_app_node_type = '$type' $orIsaSample)
              )
SQL

    $fieldsSh->execute();

    while(my ($field, $fieldType) = $fieldsSh->fetchrow_array()) {
      push @fields, [$field, $fieldType];
    }
    $fieldsSh->finish();
    
    my @sortedFieldsArray = sort{ $a->[0] le $b->[0] } @fields;

    my @sortedFields = map { $_->[0] } @sortedFieldsArray;

  
  my @prefixes = (undef, 'Shiny');
  
  foreach my $prefix (@prefixes) {

    createEmptyTable($dbh,$suffix, \@sortedFieldsArray, $record, $prefix);
    
    my $fieldsString = join(",", @sortedFields);
    
    # prefix a comma if it isn't empty
    $fieldsString = ", " . $fieldsString
        if $fieldsString;
    
    my @bindVars = map { $_->[1] eq "number" ? "apidb.parse_and_round_number(?)" : $_->[1] eq "date" ? "apidb.parse_date(?)" : "?" } @sortedFieldsArray;

    my $bindVarsString = "?,?,?,?,?," . join(",", @bindVars);
    
    my $insertStatement;
    if($prefix eq 'Shiny') {
      $insertStatement = "INSERT INTO ${record}${prefix}Attributes$suffix(protocol_app_node_id, name, description, type_id, type $fieldsString) VALUES ($bindVarsString)";
    }
    else {
      $insertStatement = "INSERT INTO ${record}${prefix}Attributes$suffix(${record}_pan_id, ${record}_name, ${record}_description, ${record}_type_id, ${record}_type $fieldsString) VALUES ($bindVarsString)";
    }
    my $insertRow = $dbh->prepare($insertStatement);


    my $metaDataSql = "
    with pmd as (
                     select m.protocol_app_node_id, ot.source_id, replace(m.value, '''', '\\''') as value, ot.type
                      from PANCHARACTERISTICMETADATA m, metadatatype ot where ot.term_id = m.term_id and (protocol_app_node_type = '$type' $orIsaSample)
                      union
                      select m.protocol_app_node_id, ot.source_id, replace(m.value, '''', '\\''') as value, ot.type
                      from PANPROTOCOLMETADATA m, metadatatype ot where ot.term_id = m.term_id and (protocol_app_node_type = '$type' $orIsaSample)
    )
    select pan.protocol_app_node_id, pan.name, pan.description, pan.type_id, ot.name as type, meta.value
    from (select protocol_app_node_id,
--               listagg(value, ',') within group (order by value) as value
                 regexp_replace(regexp_replace(regexp_replace(rtrim(xmlagg(XMLELEMENT(e,text,',').EXTRACT('//text()') ORDER BY text).GetClobVal(),','),
                                                              '.quot;', '\"'),
                                               '.gt;', '>'),
                                '.apos;', '''') as value
          from (select protocol_app_node_id, '\"' || source_id || '\"=> ''' || listagg(value,',') within group (order by value)  || '''' as text
                from (pmd) 
                where type != 'number'                
                group by protocol_app_node_id, source_id, type
                UNION
                select protocol_app_node_id, '\"' || source_id || '\"=> ''' || avg(replace(value, ',', ''))  || '''' as text
                from (pmd) 
                where type = 'number'                
                group by protocol_app_node_id, source_id, type
          )
          group by protocol_app_node_id
         ) meta,
         study.ProtocolAppNode pan, sres.OntologyTerm ot
    where meta.protocol_app_node_id = pan.protocol_app_node_id
      and pan.type_id = ot.ontology_term_id
";
    print STDERR "metaDataSql-->>\n$metaDataSql\n<<-- end of metaDataSql\n"
        if $debug;

    my $metaSh = $dbh->prepare($metaDataSql);
    $metaSh->execute();
    while(my ($id, $name, $desc, $typeId, $type, $metadata) = $metaSh->fetchrow_array()) {

      my $hashString = "{ $metadata }";
      print STDERR "hashString-->>\n$hashString\n<<-- end of hashString\n"
          if $debug;
      my $hashref = eval $hashString;

      if($@) {
        die "Error evaluating string: $@";
      }

      my @values = map { $hashref->{$_} } @sortedFields;

      $insertRow->execute($id, $name, $desc, $typeId, $type, @values);
    }
    $insertRow->finish();

    $dbh->commit();

    createIndexes($dbh, $suffix, $record, $prefix);
  }
}


  $dbh->disconnect();
}

sub createEmptyTable {
     my ($dbh, $suffix, $fields, $record, $prefix) = @_;

     my %f = ("number" => "number", "string" => "varchar2(2000)", "date" => "date");

     my $fieldsString = join(",\n", map { $_->[0]." " . $f{$_->[1]} } @$fields);
     # prefix a comma if it isn't empty
     $fieldsString = ", " . $fieldsString
       if $fieldsString;


     my $sql;

     if($prefix eq 'Shiny') {
       $sql = <<SQL;
     create table ${record}${prefix}Attributes$suffix (
       protocol_app_node_id number(10),
       name varchar2(200),
       description varchar2(3000),
       type_id number(10),
       type  varchar2(400)
       $fieldsString
  ) nologging
SQL
     }
     else {
       $sql = <<SQL;
     create table ${record}${prefix}Attributes$suffix (
       ${record}_pan_id number(10),
       ${record}_name varchar2(200),
       ${record}_description varchar2(3000),
       ${record}_type_id number(10),
       ${record}_type  varchar2(400)
       $fieldsString
  ) nologging
SQL

     }

    $dbh->do($sql) or die "creating table";


$dbh->{PrintError} = 0;
}

sub createIndexes {
     my ($dbh, $suffix, $record, $prefix) = @_;

    $dbh->do(<<SQL) or die "creating index";
      create index ${record}${prefix}att_panid_ix$suffix
      on ${record}Attributes$suffix (protocol_app_node_id, name)
      tablespace indx
SQL

    $dbh->do(<<SQL) or die "creating index";
      create index ${record}${prefix}patt_name_ix$suffix
      on ${record}Attributes$suffix (name, protocol_app_node_id)
      tablespace indx
SQL

}

sub usage {
  my $e = shift;
  if($e) {
    print STDERR $e . "\n";
  }
  print STDERR "usage:  buildSampleAttributesTT -instance <instance> -propfile <file> -suffix <NNNN> [ -schema <login> ] [ -debug ] [ -help ] \n";
  exit;
}

1;
